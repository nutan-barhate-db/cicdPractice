name: Release222

on:
  push:
    branches:
      - release/*
  pull_request:
    branches:
    - release/*
  workflow_dispatch:
jobs:
  create_initial_tag:
      if: github.event_name != 'pull_request'
      runs-on: ubuntu-latest
      env:
       GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      steps:
        - name: Checkout code
          uses: actions/checkout@v2
          with: 
            fetch-depth: 0
          
        - name: Extract tag version from release branch name
          run: echo "RELEASE_TAG=${GITHUB_REF#refs/*/}" >> $GITHUB_ENV
        - name: OUTPUT RELEASE_TAG
          id: extag
          run: |
           echo $RELEASE_TAG5
           echo ${{ env.RELEASE_TAG }}
           tg=(${RELEASE_TAG//// })
           echo "ETAG=${tg[1]}.0" >> $GITHUB_ENV
                           
        - name: Tag the commit and push to repo
          run: |
            echo $ETAG
            git config user.name "Github Action Bot"
            git config user.email "<>"
            git tag -a v${ETAG} -m "tag version v${ETAG}" 
            git push -u origin v${ETAG}
            git tag
            
  increment_tag:
      #if: github.event_name == 'pull_request'
      runs-on: ubuntu-latest
      env:
       GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      steps:
        - name: Checkout code
          uses: actions/checkout@v2
          with: 
            fetch-depth: 0
        - name: print
          run: echo "test"
        - name: print latest tag and increment patch
          run: |
           latestTag=$(git describe --tags `git rev-list --tags --max-count=1`)
           echo $latestTag
           #replace . with space so can split into an array
           VERSION_BITS=(${latestTag//./ })

           #get number parts and increase last one by 1
            VNUM1=${VERSION_BITS[0]}
            VNUM2=${VERSION_BITS[1]}
            VNUM3=${VERSION_BITS[2]}
            PATCH=${VNUM3+1}
            NEW_TAG=$VNUM1.$VNUM2.$PATCH
            echo $NEW_TAG
            #get current hash and see if it already has a tag
            GIT_COMMIT=`git rev-parse HEAD`
            #NEEDS_TAG=`git describe --contains $GIT_COMMIT`
            NEEDS_TAG=`git describe --exact-match $GIT_COMMIT`
            
            echo $NEEDS_TAG
            
            if [ -z "$NEEDS_TAG" ]
            then
                echo "Tagged with $NEW_TAG (Ignoring fatal:cannot describe - this means commit is untagged) "
                git tag $NEW_TAG
                git push --tags
            else
                echo "Already a tag on this commit"
            fi    
